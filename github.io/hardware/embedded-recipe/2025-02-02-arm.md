---
layout: single
title: "[임베디드레시피][핵심요약] ARM"
categories: hardware/embedded-recipe
---

## ARM Inside

- 32bit RISC processor
- Big/Little Endian 지원
- Fast Interrupt Response

![ARM7-TDMI아키텍처](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FCjTus%2Fbtsg2jaOwXg%2FAAAAAAAAAAAAAAAAAAAAAA64-By_-RexQAxPBJcj9lwHnRpljczp7aTp4hS280P3%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D2P7%252FHMCWegYcTJA%252FCUyb3CZ82aA%253D)

- Register Bank : 32bit 범용 레지스터 31개 + Status 레지스터 6개
- Barrel Shifter : bit shift 연산기
- Control Logic : Control 신호와 동작 담당

## CISC vs RISC

- CISC : Complex Instruction Set Computer, 기계어 한 줄에 여러 Micro Instruction들이 숨어서 실행됨
- RISC : Reduced Instruction Set Computer, Hard Wired 방식 디자인(기계어 한 줄에 해당하는 논리회로를 구성)

> RISC : 명령어 길이가 고정되어있고 단순함 => 복잡도가 단순해지고, 크기도 작아지고 전력소비가 줄어듬, 대신 CISC에 비해 여러줄에 거쳐 실행해야 하는 일이 생김
> ARM : Advanced RISC Machine

## ARM mode와 Thumb mode

> 상태 mode : ARM core가 몇 bit로 동작할 것이냐
> ARM mode : 32bit 기계어 기반 동작
> Thumb mode : 32bit machine에서 동작하는 16bit 기계어, 당시 16bit data line을 가진 메모리가 주를 이루어서 지원하게 됨

- word : CPU가 한 번에 처리할 수 있는 크기

## ARM 동작 mode

- USR(User) : 일반 프로그램 실행 모드
- SYS(System) : 권한을 부여받은 OS 태스크 동작 모드
- FIQ : 높은 우선순위 인터럽트(Fast Interrupt) 동작 모드
- IRQ : 낮은 우선순위 인터럽트(Normal Interrupt) 동작 모드
- SVC(Supervisor) : SWI instruction (소프트웨어 인터럽트 instruction - 예. SWI 0x80)이 실행될 때 사용되는 보호된 OS 모드
- ABT(Abort) : memory access violations을 위한 동작 모드
- UND(Undef) : undefined instructions 을 위한 동작 모드

> 어떤 모드를 써야할까? 취향에 따라 상황에 따라 사용하면 됨

- USR 모드를 제외한 나머지는 Privileged mode 임.
  - 각 Privileged mode끼리는 모드 전환이 가능함
  - Privileged mode는 IRQ나 FIQ의 인터럽트 사용 가능 유무를 직접 설정 가능함
- ARM의 default 모드는 SVC 모드로, 부팅시 모든 권한을 행사 가능함.

#### SWI (소프트웨어 인터럽트)의 용도

- System Call
  - SWI의 주요 용도임
  - 응용 프로그램이 하드웨어 자원에 접근하거나, 메모리 관리, 프로세스 생성/종료등과 같은 특권 작업을 OS에게 요청할때 사용
  - 각 서비스(파일 열기, 파일 읽기, 메모리할당 등)에 고유의 SWI 번호가 매겨짐
- 권한 상승 및 모드 전환
  - SWI는 사용자 모드에서 Supervisor 모드와 같은 더 높은 권한 모드로 안전하게 전환하는 메커니즘을 제공함

## ARM Register와 Context

![ARM레지스터](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FLFVOC%2Fbtsg1szdA0C%2FAAAAAAAAAAAAAAAAAAAAACWsjPAqQtpjYENTRoiToXNExwIj1insaDei8yjMuVQU%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D9%252FXRSo3R%252FJasS%252FmaNOiUrt5XGuY%253D)

- ARM은 모드가 바뀌면 레지스터 set도 바뀜
- 각 모드는 : R0~R15 + (CPSR + SPSR)의 레지스터를 가짐
- banked register(삼각형 표시된 부분)은 각 모드별로 가지고 있는 레지스터이고 나머지는 공용으로 사용함

![ARM실제레지스터](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbRvnLA%2Fbtsg2jaWzKa%2FAAAAAAAAAAAAAAAAAAAAAJrzIP4eADaoP7t_ut-Bq5DesNfkduk1QoIHwVL7d7V8%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Dz996dW5aV4RVYkPKyc9JMA9Vpac%253D)

공용레지스터를 겹치지 않게 표현하며 위와 같고, 실제로 총 37개의 물리적인 레지스터가 존재함

#### R0~R12 : CPU 동작 중 일반 저장용도로 사용

#### R13 : Stack Pointer

- 현재 Stack을 어디까지 쌓아 두었는지 기록해 놓는 특수 용도 레지스터

#### R14 : Linked Register

- branch시 돌아갈 주소를 저장해 놓는 특수 용도 레지스터

#### R15 : Program Counter

- (실행하는 위치가 아닌)Fetch해온 위치를 가리키는 특수 용도 레지스터

#### CPSR : Current Program Status Register

![CPSR](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fdtj3Iq%2FbtsgL83AJfr%2FAAAAAAAAAAAAAAAAAAAAAPTId8m3osDteIg673VPwGWm1eR5_K9p0ID5iItnJv7c%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DOcyBGxcij01%252FmN8CPiUlIw9EdbM%253D)

- NZCV : Condition Flag field, 연산 결과에 따라 값이 세팅됨
  - N(Negative) : 연산 결과가 마이너스인 경우 set
  - Z(Zero) : 연산 결과가 0인 경우 set
  - C(Carry) : 연산 결과에 Carry가 발생한 경우 set
  - V(Overflow) : 연산 결과가 overflow 났을 때 set (원래 가져야하는 range보다 결과 값이 큰 경우)
  - Fetch를 무조건 실행하지 않고, 이 Condition Flag field를 보고 결정하기도 함
- IF : IRQ와 FIQ의 Disable 여부 지정(1: Disable, 0: Enable)
- T : Thumb mode 여부
- mode : 현재 동작 모드, 이걸 세팅하면 그 모드로 전환도 됨

#### SPSR : Saved Program Status Register

- CPSR를 복사(백업)해 놓는 레지스터
- SPSR에 CPSR을 백업해놓고, 모드를 바꾸었을 떄 다시 SPSR의 값을 CPSR로 집어 넣어 이전 모드로 복귀함

> R13~R15, CPSR, SPSR은 Special Purpose Register라고 구분함

#### Context

![컨텍스트](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FEnntL%2FbtsgMaG8eAN%2FAAAAAAAAAAAAAAAAAAAAAJI0DZhvABq3BoLtPVZDnCUxHRi8taQuGCjRL6Z9TRNF%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DTSQaPk%252FMKVNIKTpFJE9zCWuF5vo%253D)

> Context란? 현재 MCU가 동작하는 환경 (레지스터 set의 스냅샷)을 의미함

- Context Switching은 환경을 변경하는 것을 의미함
- Context(레지스터 set의 스냅샷)을 저장해놓으면, 다시 해당 순간으로 돌아갈 수 있음

#### 예외 모드 vs User 모드 + System 모드

- User 모드와 System 모드는 R0~R15 + CPSR을 모두 공유하고, CPSR의 모드를 나타내는 필드만 다름
- SPSR은 Exception 발생시 현재 CPSR을 저장하기 위한 용도이기 때문에 Exception 모드가 아닌 User모드 + System모드에서는 필요가 없음
- Exception 모드는 Exception(Fast Interrupt, Normal Interrupt, SWI, Abort, Undefined)를 통해 전환됨

#### Q&A

- System모드가 왜 필요할까?
  - 주로 커널스레드 실행에 사용됨
  - 운영체제 커널의 대부분은 Supervisor 모드에서 실행됨,
  - 커널 스레드가 Supervisor 모드에서 실행되고 context switching이 자주 일어난다면 레지스터를 스위칭해야하는 오버헤드가 발생할 수 있음
  - User모드와 동일한 레지스터를 사용하는 System 모드를 도입해 스위칭시 오버헤드를 줄이고자 함
- 왜 R8~R12의 색깔이 다른가? Thumb mode는 R0~R7만 사용하고, ARM mode에서는 R0~R12까지 모두 사용함
- Context 전환은 어떻게 하나? stack에 register를 백업해놓았다가 복구하는 방식으로 전환함
- FIQ의 banked register는 왜 더 많은가? 빠른 동작을 위해 register backup을 하나라도 덜하기 위해서!

## ARM Exceptions 과 모드

Exception이 발생하면 진행하던 동작을 멈추고, Exception의 종류에 해당하는 모드에 진입하고, 해당 주소로 PC를 점프시킴

#### 각 모드별 CPSR과 진입 유발자

![각 모드별 CPSR과 진입 유발자](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FuiiiU%2FbtsgMa78XjF%2FAAAAAAAAAAAAAAAAAAAAAFVEr7iDXcDAPDcnBBJphmp9JnTFYc81SoeV6AJt-hSa%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DlomO%252B%252BRjCa0Q5qWMnDP5auFQkt4%253D)

- ARM의 전원 인가 or reset : SVC 모드 진입, PC를 0x0으로 점프
- IRQ, FIQ : Interrupt 발생시 해당 모드 진입, PC를 0x1C 또는 0x18로 점프
- ABORT : data abort 발생시(MMU나 MPU에 의해 access protection이 걸려있는 곳 접근) ABORT 모드 진입, PC를 0x10으로 점프
- UNDEF : undef exception(instruction decode시 모르는 instruction일 때) 발생시, PC를 0x04로 점프

PC를 점프시킨다는 말은 PC값을 그 값으로 세팅한다는 말임

#### Exception Vector table

Exception이 발생했을 때 점프하는 Address를 모아 놓은 테이블

![ExceptionVectorTable](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2F4vqxX%2FbtsgYjDajlD%2FAAAAAAAAAAAAAAAAAAAAAIOnhRA3V7ArZkb1tK_FcPmCQ8sQO52I1qMw1wbw80Iq%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D%252Bwp4GFgnb9uvQRI6i%252BA0Yju5Pqc%253D)

- 기본적으로는 HW적으로 각 Exception에 대한 pc 주소가 이미 정해져 있음
- 특정 레지스터를 통해 순서등을 바꿀 수는 있음
- 각 주소마다 각 모드 진입시 진행할 코드의 포인터를 Branch 명령어를 넣는 식으로 코드를 작성함

> High Vector/Low Vector란? Vector 테이블이 낮은 주소에 위치할 것이냐, 높은 주소에 위치할 것이냐를 정해주는 것임. 최근에는 낮은 주소에 부트관련 코드를 넣고, 높은 주소 벡터 테이블을 사용하는 형태가 많아짐

#### 모드 진입 관계

![모드진입관계](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcMiJca%2Fbtsg0NX14Ms%2FAAAAAAAAAAAAAAAAAAAAANuOHecPmmCoL_a8C5oKRfwIJMLESQM16F_XbJ6c1Kog%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Doh1oSDPcbtCqK8coqD2Gd1z7uno%253D)

- privileged 모드에서는 어떤 모드로 변경이 가능함
- user 모드에서는 어떤 모드로든 변경이 불가능함
- user 모드가 너무 힘이 없으니, privileged user 모드의 느낌으로 system mode를 만듦(?)

#### Exception 우선 순위

1. Reset
2. Data abort
3. FIQ
4. IRQ
5. Prefetch abort
6. undefined
7. SWI

> undefined가 순위가 낮은 이유? 다른 coprocessor나 주변기기를 직접 Assemble로 control할 때, 일부러 undefined instruction을 발생시키기도 함

#### Context 전환시 해야할 일

![컨텍스트전환](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fblwkjw%2FbtsgGlPDjMY%2FAAAAAAAAAAAAAAAAAAAAAOpHvrpPloN5FBT_NUKUejqPuGY8abXw6QNzntU_gdyc%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DS5CYKB6xuAEIijoRYcLG03xJTNM%253D)

- ARM state로 복원 : Thumb state 모드로 동작하더라도, Exception은 ARM state 모드로 처리함

> 위 일 중 어떤 부분은 SW적으로, 어떤 부분은 HW적으로 실행되는데 ARM 종류에 따라 HW적으로 어디까지 지원해주는지가 조금씩 달라짐

#### Q&A

- System/User 모드는 왜 spsr이 없는가? Exception으로 인해 진입하는 모드가 아니고 평소에 동작하는 모드라서, 굳이 CPSR을 저장할 필요가 없다는 의도이고, 만약 저장할 필요가 있을 경우엔 stack에 넣어주면 됨

## ARM/Thumb PCS - 레지스터 사용법

- APCS(ARM Procedure Call Standard) : 특수 목적 레지스터외 일반 레지스터들을 어떻게 쓸 것인가에 대한 약속
  - 함수를 부를 때, register는 어떻게 사용할 것인가?
  - return 값을 어떻게 돌려줘야하는가?
  - Stack은 어떨 때, 어떻게 사용되는가?
  - 위 경우를 제외한 나머지 레지스터는 어떻게 사용할 것인가?

AAPCS(Procedure Call standard for ARM Architecture) : APCS는 구버전이고, 최근 버전은 AAPCS
![AAPCS](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FxVFTv%2FbtsgTjwGafp%2FAAAAAAAAAAAAAAAAAAAAAFf3jULW2TkVSc9spf0WJLmkW9-D5n8uz7R6pJH2YNaU%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Dx9yyDzJSnPGK%252FsQi1ordp7PmYqo%253D)

> 컴파일러 옵션에 -apcs라고 하면 이 AAPCS 규칙에 따라 컴파일해줌

#### Synonym & Special

- Synonym : R0~R11 까지 레지스터의 또 다른 이름
- Special : 특별한 기능을 위해 사용하는 레지스터의 또 다른 이름
- 주로 a1, a2, a3, a4와 SP, LR, PC 정도를 사용함

#### R0~R3(a1~a4) : Argument/Result/Scratch

- Argument : 함수의 파라미터 용도로 사용, 보통 R0(a1)에 return 값을 넣음
- Result : R0~R3 까지 다 활용해 16바이트까지 한 번에 return 핼 때 사용 or 포인터를 넘기고 다시 그 포인터를 받는데 사용
- Scratch : 연습장, 전달 수단으로 쓰이고 나면, 임시저장용도로 사용함

> 레지스터 개수를 넘기는 argument나 return은 stack을 사용함

#### R4~R11(v1~v8) : Variable

- 함수 호출 후 변경되면 안되는 값
- 만약 호출 당한 함수가 이를 다른 용도로 사용 하려면 stack에 값들을 저장해놓고, 호출당한 함수가 끝나기 전 다시 복구해줘야함

#### R12~R15 : 특수 레지스터

## ARM은 Interrupt 냄새를 어떻게 맡는가?

#### 인터럽트 컨트롤러

![인터럽트컨트롤러](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbcM1AA%2FbtsgKpdcL4s%2FAAAAAAAAAAAAAAAAAAAAANtj0dWCnmSeM5z97gDwTjDvKnyNoHs7rf2qpAGVJBCJ%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DDIANu4LwhMa6F5RgrH7XIdmenb0%253D)

- MCU안에는 인터럽트 컨트롤러라는 IP가 있음
- 인터럽트 컨트롤러는 MCU외부의 외부 인터럽트나 MCU 내부의 내부 인터럽트 wire가 이어져 있음

> 인터럽트가 들어오면 인터럽트 컨트롤러가 CPU에게 nIRQ나 nFIQ 를 통해 전달함

#### CPU

![ARM7-TDMI아키텍처](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbdH6Gj%2Fbtsg1eA3Qq2%2FAAAAAAAAAAAAAAAAAAAAANXj9RWEkLW5Cg6tB5gLs3w9fDxcOd0h67X7XnA86ljG%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3Dbp9CAkkHjpZ6I2%252FUU9yCNxA4YuE%253D)

- Control logic에 nIRQ, nFIQ가 붙어 있음
- n이 붙는 이유는 인터럽트가 여러 개일 수 있고, 각 인터럽트당 번호를 부여해서 사용함
- 인터럽트 처리방법 : IRQ mode에 진입 > handler에서 레지스터를 확인해 몇 번 인터럽트가 들어왔는지 보고 > 해당 interrupt에 대한 ISR을 실행함
- Nesting (인터럽트 처리중 다른 인터럽트가 들어온 경우) : 인터럽트 처리하는 동안 허용을 안하는 방법도 있고, 몇 번에 걸친 Nesting은 허용해주는 방법도 있음
- Bottom Half : 중요한 요건만 최대한 빠르게 끝내고, 나머지 일은 나중에 처리함

## ARM SoC

![SoC](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FO6tTk%2Fbtsg0oqGdU6%2FAAAAAAAAAAAAAAAAAAAAAOqNBchQ0WgUfYp_7P4WgC3cKnMmNz9zp4q0rwrTWi32%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DBgk2ALbpu6W03pMwAeyxA0JMaTo%253D)

- SoC(System on Chip) : ARM core와 더불어 다양한 IP를 한 Chip에 모은 것
- SoC 환경에서 각 IP끼리 통신할 수 있는 규격이 필요했고, 이걸 위해 ARM 사에서 제안한 버스 프로토콜이 **AMBA**임

## AMBA - SoC안에서 IP끼리의 Bus 규격

> AMBA : SoC 내부에 IP들끼리 어떻게 통신하고, 어떻게 연결할 것인가에 대한 약속, ARM의 성능을 잘 끌어낼 수 있도록 디자인됨

#### 버스 인터페이스 종류 3가지

- AHB(Advanced High Performance Bus)
- ASB(Advanced System Bus)
- APB(Advanced Peripheral Bus)

![AMBA구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FvguXB%2FbtsgKpEg1bF%2FAAAAAAAAAAAAAAAAAAAAAOuoT0l7nMTA1VAfVfqiDr6xPSl3YvhWnc9iwAlYdoNr%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DaOBhlvR%252FnB0ySHuWUhR5vcX7pK8%253D)

- 속도에 따라 각 IP는 AHB 또는 APB 버스에 물려있음
- AHB, APB는 버스 속도가 달라 Bridge를 통해 연결됨
- 각 IP는 Master도 되고 Slave도 될 수 있음
- Master는 Slave에게 Read 또는 Write 요청을 하고, Slave는 그 요청에 따라 Read/Write를 하게 되고 response(성공/실패/wait)등의 응답을 Master에게 보냄

#### 아비터

![아비터](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fd2ielN%2FbtsgL9uEFj7%2FAAAAAAAAAAAAAAAAAAAAAJgUM9T_jlqHaNqMJWUxaRf1U2jxcOn7dNzSi-QsOnTZ%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D6742sZV8b56FYDhpvtbnHEtK9Mc%253D)

- AMBA에서 마스터와 슬렙이브는 16개까지 붙을 수 있음
- 디코더 : 마스터와 슬레이브의 길을 뚫어주는 역할

순서

1. 마스터가 아비터에게 HBUSREQ(버서써도돼?) 날림
2. 아비터가 상황(우선순위, 버스사용여부등)을 보고 마스터에게 HGRANT(어!써)를 날림
3. 마스터가 아비터에게 hlockx(나이제쓴다)를 날림
4. 아비터는 내부적으로 누가 버스를 쓰고 있는가 기록하게 됨.
5. 마스터가 디코더에게 접근하려는 슬레이브의 주소 HADDR을 날림 > 디코더가 HSELx신호를 슬레이브에 날림
6. 마스터가 슬레이브에게 HWRITE(쓸께) 신호를 날림
7. 슬레이브가 마스터에게 HREADT(어!준비됐어) 신호를 날림
8. 마스터가 슬레이브에게 HWDATA에 데이터를 날림

![순서타이밍다이어그램](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcMKsoW%2FbtsgMcdTyEO%2FAAAAAAAAAAAAAAAAAAAAAD4phfAB4JeBDUPZW0Djsj9bFOc7LecnRmQf5GNNVeXx%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DDSLK%252B5BKs08LJVw1Y4gtrCptPtQ%253D)

- Address Phase : Address를 날리는 구간
- Data Phase : Data를 날리는 구간
- wait : 슬레이브가 마스터에게 아직 준비 안됐어...어! 됐어 하는 구간
- HTRANS[1:0] : Control 신호 중 일부, 버스트 트랜스퍼 방식을 결정

HTRANS
![HTRANS](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FcvacEn%2Fbtsg1sF2g9h%2FAAAAAAAAAAAAAAAAAAAAAAVriUmumV174xDaPbdpPPzDHCBz9A1zHW4z79kmtDul%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DUCZbZx6ncSF%252B8O6wDZQvjMMA%252BcI%253D)

#### 버스트 트랜스퍼

- 데이터를 보낼 때, 연속된 주소의 데이터의 경우, 주르륵 보내는 것
- 하나의 Address + 하나의 data가 아니라 하나의 Adress에 여러 data를 쓸 수 있는게 장점
