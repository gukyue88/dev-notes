---
layout: single
title: "[임베디드레시피][핵심요약] Software의 정체와 만들기"
categories: hardware/embedded-recipe
---

## 알아두면 좋은 용어

#### Little Endian 과 Big Endian

> Endian : 데이터를 저장할때 byte ordering

- data : 0x12345678
- Little Endian : 0x78 / 0x56 / 0x34 / 0x12 (낮은주소에 낮은 쪽 바이트부터)
- Big Endian : 0x12 / 0x34 / 0x56 / 0x78 (높은 주소에 낮은 쪽 바이트부터, 인간이 보기 쉬움)

> ARM의 경우, Default가 Little Endian으로 동작함.
> C 컴파일러 옵션으로 Endian 지정 가능함

#### MSB, LSB

- MSB : Most Significant Bit, 큰쪽 비트를 의미, 사람이 봤을 때 숫자의 왼쪽, 위 데이터에서 MSB 8bit == 0x12
- LSB : Least Significant Bit, 작은쪽 비트를 의미, 사람이 봤을 때 숫자의 오른쪽, 위 데이터에서 LSB 8bit == 0x78

#### Assembly 언어

기계어(1과 0으로 이루어짐)과 1대1 매칭되는 사람이 이해하기 쉬운 언어

- 컴파일 : 인간의 코드를 기계어로 변경해주는 일

#### 크로스컴파일

- Processor마다 기계어가 다름
- 크로스 컴파일 : C/C++ 같은 고수준 언어를 타겟 Processor맞게 기계어로 컴파일 해주는 일
- 작업이 편한 PC에서 Target Processor의 바이너리를 컴파일 함.

#### DWARF

- Executable ELF 중 `*.debug` 섹션(지역, 전역 변수들에 대한 디버깅 심볼)에 어떻게 정보를 넣을 것인가 하는 규칙이 있음
- ARM에서 사용하는 규칙이 DWARF 방식
- 이를 통해 Trace32로 디버깅하는 등에 사용함

#### `*.axf` 파일

- ARM Executable format 중 하나
- DWARF 2.0 규격을 따르는 포맷
- `*.elf`와 나머지는 같고, `.debug` 섹션이 DWARF 2.0 규격으로 작성됨

## 컴파일 과정

![컴파일과정](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2F6t1qZ%2Fbtsg0W8ujhX%2FAAAAAAAAAAAAAAAAAAAAAHynBBB2iRDwArahlNqsRgla2YVeJ_78nzWXIAtYbOlH%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DREKVBEzdxLPX%252FFVUk83KL9Y9MbI%253D)

- 파일
  - Source (`*.c, *.h`) : 소스 코드 파일
  - Source (`*.s`) : 어셈블리(기계어1:1매칭) 파일
  - `*.o` : 오브젝트 파일, 기계어 및 링크를 위한 심볼 포함됨
  - `*.lib` : 라이브러리 파일, `*.o`를 단지 압축(archive)한 파일
  - `*.bin` : 순수 기계어 파일
  - `*.scl` : Scatter Loaindg, 메모리 구성을 원하는대로 설정하는 스크립트 파일
  - `*.map & *sym` : 바이너리의 메모리 구성을 나타내는 text file
  - `*.a` : 리눅스 계열에서 사용하는 정적 라이브러리 파일 (공유 라이브러리의 경우 `*.so`)
- 과정
  - 컴파일러 : 소스 코드로 오브젝트 파일을 생성
  - 어셈블러 : 어셈블리 코드로 오브젝트 파일을 생성
  - Archiver : (라이브러리 제공을 원하는 경우 사용) 오브젝트 파일들을 하나로 압축하여 라이브러리 파일 생성
  - Linker(armlink) : 오브젝트 파일 및 라이브러리, Scatter Loading을 입력 받아, 공유 오브젝트 파일 또는 실행 가능한 이미지 또는 맵/심볼 파일 생성
  - fromelf : 실행가능한 파일(`*.elf`)로 실제 순수 기계어(`*.bin`) 생성

## 전처리 과정

> 전처리(Preprocess) : #으로 시작하는 MACRO나 DEFINE을 컴파일전 그대로 코드에 치환함

전처리만 하는 옵션

```sh
tcc -E spaghetti.c > spaghetti.i
```

- spaghetti.h와 spaghetti.c가 spaghetti.i 파일 하나로 합쳐짐
- #define이나 #include에 의한 실수를 찾거나, #ifdef로 지저분한 코드를 분석할 때 도움됨

#### #include

파일의 코드 자체를 거기에 옮겨놓는 것임. 헤더 파일 뿐 아니라 .c도 include 가능

![include](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FU4qjg%2Fbtsg3V8TyyK%2FAAAAAAAAAAAAAAAAAAAAAL3sIxhcHleATXdgrr4SLtpH-V3jXGUxgmHwfRO376Ph%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DkFtV2vHY2cPDkqvli66nuGvEH94%253D)

`#include ""` : .c가 있는 디렉토리의 상대 경로
`#include <>` : predefined된 경로

> -I 옵션 : include 경로를 추가할 수 있음
> -J 옵션 : Compiler Default Include Path 변경 (standard library 변경 가능)

#### 이중 include 피하기

```c
#ifndef __SPAGHETTI_H__
#define __SPAGHETTI_H__
...
#endif
```

![이중include](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbwbZ9R%2Fbtsg1WHf42A%2FAAAAAAAAAAAAAAAAAAAAAKr7O-_9SmZkhS1Kap3jWrWyhb2Hym0yf9O7o2A4vR9L%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DjgJeigiBCP905X0%252FVBQeu%252FFimKk%253D)

## Library - 남한테 보여주기 싫어

라이브러리 : 미리 컴파일 해놓은 object 파일의 모음

- 자주 사용하는 함수를 굳이 매번 compile 하지 않고, 미리 만들어두고 link만 할 때 사용
- source code를 공개하고 싶지 않을 때도 사용

라이브러리(도서관)이라는 이름을 붙인 이유는 도서관에서 원하는 책을 찾는 것처럼 미리 컴파일 해둔 Obect 파일 중 필요한 것만 찾아 새로 연결하면 되서임.

Archive란? 컴파일된 오브젝트 파일들을 압축해서 한 개의 파일로 관리하는 것, lib과 동일한 의미

#### recipes.lib 파일 생성

```
armar -r recipes.lib spaghetti.o applejuice.o ramen.o
```

> 링커는 이런 lib 파일도도 다른 object 파일처럼 linker의 input으로 사용함

#### 정적 library vs 공유 library

> 위에서 얘기한 라이브러리는 \*.o 의 집합이고, 여기서 얘기하는 정적/공유 라이브라리와 조금 다른 개념임

- 정적 library는 link를 하고 나면 하나의 binary 파일에 녹아 들어감
- 공유 library는 OS에서 load되면 다른 application 에서도 공유하여 사용 가능함

> OS가 없는 embedded system에서의 library는 정적 library임.

## lib을 까보자

3rd party가 준 lib을 까고 싶을때!

armar을 사용해 lib(archive)를 만들 수도 있지만 까보고 수정할 수도 있음

```sh
armar -t 라이브러리명 # 오브젝트 리스트를 보여줌
armar -zs 라이브러리명 # 오브젝트와 그 안에 symbol까지 보여줌
armar -d 라이브러리명 오브젝트명 # 해당 라이브러리에서 해당 오브젝트를 제거
armar -c 라이브러리명 새로운오브젝트명 # 해당 라이브러리에 새로운 오브젝트를 추가
```

## 컴파일러 Option들

- `-o` : output 파일명 별도 설정
- `-E` : 전처리만 실행, `-C` (전처리시 주석을 그대로 두는 옵션)
- `-S` : .s(어셈블리) 파일 생성
- `-c` : link는 하지말고 .o(오브젝트) 파일 생성
- `-I` : 헤더 파일을 include할 경로 추가, (주의 : 빈칸이 없어야 함. 예. `-Idir`)
- `-J` : 디폴트 Include 경로 변경
- `-D` : `#define`, 예. `-DFEATURE_OPT` == `#define FEATURE_OPT`, `-DTHREE=3` == `#define THREE 3`
- `-U` : `#undef`, code 안에 define을 무력화시킬때 사용
- `-g` : DWARF 정보(Debugging 정보보를 ELF 파일에 넣기
- `-W` : Warning 레벨 결정
- `-O1`, `-O2` : 최적화 수준
- `-l` : 컴파일시 특정 라이브러리도 함께 input으로 추가
- `-L` : 라이브러리 include 경로 추가

## 변수의 scope와 그 생애 (Memory Map)

#### 변수의 유형

- auto : auto 로컬 변수, 접근은 해당 블록(또는 함수) 내, 생애주기 == 자신을 둘러싼 block(또는 함수), auto 키워드를 별도로 쓰지 않음
- extern : GLOBAL 변수, 접근은 정의 위치부터 파일 끝까지, 생애주기 == 프로그램 시작부터 끝까지, extern 키워드를 사용하여 다른 파일의 GLOBAL 변수를 사용 가능
- static : local static 변수와 global static 변수로 나누어짐
  - local static 변수 : 함수 안에서만 접근 가능하나, 생애주기 == 프로그램 시작부터 끝까지
  - global static 변수 : 접근은 해당 파일에서만 가능 (다른 파일에서 extern으로 사용할 수 없게 방지하는 역할), 생애주기 == 프로그램 시작부터 끝까지
  - 정리 : static은 항상 값은 유지하되, 해당 함수 또는 파일에서만 쓰겠다는 의미로 쓰임
- volatile : 컴파일러 최적화 방지, memory mapped I/O에서 레지스터 값을 R/W할 때 최적화를 방지하기 위해 쓰임

## Memory Map과 Symbol 이야기

#### symbol table

- 링커를 위해서 object 파일 안에 symbol table을 둠
- symbol table 안에는 symbol에는 이름(함수이름 또는 전역 변수 이름)과 함께 해당 위치정보가 들어있음
- Linker는 링크시 이런 symbol들을 주소로 모두 변환해서 바이너리로 만들어줌

#### symbol : 자기 자신만의 주소를 갖는 단위

- symbol을 갖는 것들 : 함수, 전역벽수, static 변수
- symbol을 갖지 않는 것 : local 변수

#### symbol의 메모리 영역

![symbol의 메모리 영역](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbORfGJ%2FbtshgoxS9xz%2FAAAAAAAAAAAAAAAAAAAAAHbY1t6gFNZLzu3uRRIQnmkRARSbnCmCePVSC7egNg1v%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DMCHBXtvDWVsQSWmfZbNx0I%252Bvxx8%253D)

- RO : Read Only 영역 (code, const)
- ZI : Read/Write 가능하고, 초기 값이 0인 영역
- RW : Read/Write 가능 영역

> symbol을 갖는 애들은 RO, ZI, RW 영역에 자리를 잡고, 다른 애들은 stack 영역 또는 heap 영역에 자리를 잡음

![메모리영역](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FkZ7Dr%2FbtshifNGHK3%2FAAAAAAAAAAAAAAAAAAAAAGye7PzmXT01jCOFWnVQ4Z9XfudZI0eD3nX_DLnWDWso%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DrwDqeb22E997W1BUto2uuw12qbk%253D)

위에 ZI에 heap, stack이 포함된 이유는, 임베디드 시스템상에서 heap과 stack 구현시 전역변수를 사용한 경우 ZI에 포함된다는 얘기를 하고 싶었던거임.
일반 프로그래밍에서는 heap, stack, ZI 영역이 따로 구분됨

## ELF format object File에 관한 진실 (-c option 기계어 세상)

> 여기에서 말하는 ELF는 `*.elf` 만을 뜻하지 않음

ELF는 유닉스 계열 운영체제에서 사용되는 바이너리 파일 형식의 표준임

- ELF 주요 유형
  - Relocatable file (`*.o`) : 링킹이 되지 않은 상태, 다른 오브젝트 파일과 연결될 준비가 된 상태
  - Executable file (`*.elf` 또는 확장자없음) : 링킹 과정을 거쳐 생산된 최종 실행 파일
  - Shared object file(`*.so`) : 공유 오브젝트 파일, 운영체제가 있는 상태에서 여러 프로그램이 공유해서 사용할 수 있는 라이브러리 파일

> `*.so`는 운영체제에서 사용되는 형태로 여기에서는 논외

#### ELF 파일 포맷

![ELF파일구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fqt3Jt%2Fbtshi7uO7FZ%2FAAAAAAAAAAAAAAAAAAAAAKDC2qs5ArpZZgNL_6a27RP3a4_pHYntidlMC3TuLiRP%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DeQHM1uBTOnCWBJhKKMrv8VNvVus%253D)

- Linking View : Relocatable 파일을 위한 파일 포맷 (`*.o`)
- Load View : (그림에는 표시 안됨) Executable 파일을 위한 파일 포맷 (실행은 하지 않고 실행 가능한 상태의 파일) (`*.elf`)
- Execution View : Executble 파일을 실행을 위해 실제 메모리에 올린 상태의 파일 포맷

실제 ELF 파일
![ELF파일내부](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fsz35b%2FbtshhJBMK3P%2FAAAAAAAAAAAAAAAAAAAAAL9zXZDCf2eABXZ5NQ-iR71KaPfmLFu2WjLQlt39iBCP%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DpNbB1V0U5KPKBXEb4FbgT0zjWu8%253D)

예제로 `tcc -c spaghetti.c`를 하면 `spaghetti.o`가 나오는데, 이 Relocatable(재배치가능한) 오브젝트 파일을 Linking View 포맷으로 분석하면 아래와 같음.

spaghetti.o의 구조
![spaghetti.o의구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fsz35b%2FbtshhJBMK3P%2FAAAAAAAAAAAAAAAAAAAAAL9zXZDCf2eABXZ5NQ-iR71KaPfmLFu2WjLQlt39iBCP%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DpNbB1V0U5KPKBXEb4FbgT0zjWu8%253D)

- ELF 헤더
- 섹션
  - opcode (.text)
  - data (ro)
  - tcc compiler version 정보
  - 기타 section들
- 섹션 헤더 테이블

`*.o` (재배치 가능한 ELF 오브젝트 파일) 형태 다시 정리
![재배치 가능한 ELF 오브젝트 파일](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbF7xPH%2FbtshjE0asOl%2FAAAAAAAAAAAAAAAAAAAAAAe3u8rPaMIISJfnP_WKCI2mBFcvYSbNF-jeqwqJXpMd%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3DnZlRY69fAgPUScnKYnmuMV3zZSE%253D)

- ELF Header : 각종 메타 정보가 담김
- Section : Linker가 이 오브젝트 파일을 파싱하고 해석할 수 있음
  - .text : complie된 기계어 (op code)가 들어감
  - .rodata : read only data (const등 데이터)
  - .data : 초기화된 전역변수
  - .bss : 0으로 초기화 되는 전역 변수
  - .symtab : symbol table, 전역변수 이름과 함수 이름
  - .rel.text : relocatable text, op code인데, 구멍난(현재 오브젝트 파어에 없고 다른 오브젝트 파일에서 링크가 필요한) 코드
  - .rel.data : relocatable data, data인데 구멍난(현재 오브젝트 파어에 없고 다른 오브젝트 파일에서 링크가 필요한) 데이터
  - .debug : 지역, 전역 변수들에 대한 디버깅 심볼
  - .line : -g 옵션(디버깅용) 컴파일 시 코드를 보면서 디버깅할 수 있도록 op code와 C 라인을 연할하는 정보
  - .strtab : .symtab과 .debug 섹션에서 사용되는 const data인 string등이 담김, section header의 이름도 담김
- Section Header Table

## Linker를 마무리 짓자 - ELF와 fromelf 까지

#### 링커의 역할

![링커의역할](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FoKT6g%2Fbtshh8VE26M%2FAAAAAAAAAAAAAAAAAAAAAIEvHgrOTcYsMXhhj7EQcaML4K8u4HH6R8VHRWsKM3Sz%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D21fbsOdWLLwZEI6nKAfl%252BrCWMAU%253D)

- Relocatable Object 파일들(`*.o`)을 엮어 Executable Object 파일(`*.elf` 혹은 확장자 없음)을 만들어 냄
- Relocatable Object 파일들(`*.o`)의 섹션을 같은 섹션끼리 모아줌
- Relocatable Object 파일들(`*.o`) 중 구멍난 부분(extern)을 매꿔줌 (symbol resolving)

#### Executable Object 파일(`*.elf` 혹은 확장자 없음)의 ELF 파일 포맷

![Executable Object 파일 포맷](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fbd3MK6%2FbtshbeCqEjI%2FAAAAAAAAAAAAAAAAAAAAAJWU1G3P-IUctxR51JC5TZPr6TBNNcGkgSa1z209eN-d%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D0OrbdceEIj5nn8la3DtcSUCK5FA%253D)

- ELF Header에 파일 실행시 시작되어야하는 **entry point address**가 들어감
- `rel.*` section(구멍난 곳)은 사라짐
- `.init` section이 생김 : OS가 있는 시스템에서 ELF가 실행되기전 초기화 하는 코드 + 프로그램 헤더(프로그램 실행시 필요한 몇가지 정보)
- 세그먼트 : 동일한 메모리 속성 (RO, R/W)를 가진 섹션들의 집합
  - code segment : RO 메모리 세그먼트, ELF header + Segment header table + `.init` 섹션 + `.text` 섹션 + `.rodata` 섹션
  - data segment : RW 메모리 세그먼트, `.data` 섹션 + `.bss` 섹션

#### Global Symbol 중 똑같은 이름으로 여러 군데 선언 되어있는 것이 있을 때 Link 작업은 어떻게 진행되나?

- Strong Global Symbol (함수 및 초기화된 전역변수)가 여러 개 선언된 경우 링크 에러 발생
- Weak Global Symbol (초기화 되지 않은 전역변수)의 경우, 링크 warning 발생 => 주의 필요
  - 같은 Strong Global Symbol 하나와 여러 개의 Weak Global Symbol이 있다면, Strong Global 선택
  - 여러 개의 Weak Global Symbol만 있다면, 아무거나 하나 선택

## Scatter Loading/Linker Description Script와 메모리 다루기

#### Load View와 Execution View

![LoadView와ExecutionView](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2F6pxit%2FbtshhF68bgN%2FAAAAAAAAAAAAAAAAAAAAAO_YPI7bF0lUepGSwfyyVtqOdqYgISrHq_RUc2qPpfEc%2Fimg.jpg%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1756652399%26allow_ip%3D%26allow_referer%3D%26signature%3D572GSc8re6aSRBhY8LV%252FCxPXupc%253D)

- Load View : `*.elf` (실행가능한 파일), 저장매체에 담긴 상태
- Execution View : 실제 로드되어 실행 상태

최종 실행 가능한 이미지를 만들 때

1. 코드는 실행을 위해 word 단위의 엑세스가 가능한 메모리 영역에 들어가야 함
2. 데이터는 Read/Write가 가능한 메모리 영역에 들어가야 함

#### Scatter Loading의 역할

- 실행파일의 메모리 영역(Region)을 정의 (주소 포함)
- 각 메모리 영역(Region)에 들어갈 섹션(`.text`, `.data`, `.bss`등)을 정의 (주소 포함)
- 각 섹션의 초기화 과정을 명시 : ROM에 있는 데이터를 RAM으로 복사하거나, 특정 메모리 영역을 0으로 채우는 작업

> ARM 에서는 scatter loading file 이라는 용어를 사용하고, GNU 진영에서는 Linker Description Script 라는 용어를 사용함

#### Scatter Loading 예

```
LOAD_ROM 0x0
{
  EXEC_ROM 0x0
  {
    spaghetti.o (+RO)
  }
  EXEC_RAM 0x8000
  {
    spaghetti.o (+RW)
  }
  EXEC_RAM2 0xA000
  {
    spaghetti.o (+ZI)
  }
}
```

- `LOAD_ROM 0x0` : Load View를 의미함, Load View 안에 Execution View를 정의함
- `EXEC_ROM 0x0` : ROM 0x0 부터는 spaghetti.o의 RO를 load
- `EXEC_RAM 0x8000` : RAM 0x8000 부터는 spaghetti.o의 RW를 load
- `EXEC_RAM2 0xA000` : RAM 0xa000 부터는 spaghetti.o의 ZI를 load

> Scatter Loading file은 컴파일 옵션 `-scatter`로 넣어줄 수 있음
> 주의점 : Scatter Loading file은 하나의 Root Region 이 꼭 필요함

#### Scatter Loading을 넣어주지 않는다면?

![ScatterLoading이없는경우](https://blog.kakaocdn.net/dna/bdRFMl/btshbeCqObX/AAAAAAAAAAAAAAAAAAAAAJDA7hX_1eed6XxL_X4_MNKOhA8S0hWFojj63XNydsdd/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1756652399&allow_ip=&allow_referer=&signature=1Ln4TP6z%2BJTS4i%2BTaOAoW0MjaYs%3D)

- RO -> RW -> ZI 순으로 낮은 메모리 번지부터 차차차곡 생기게 됨
- ZI 가 끝나는 지점부터는 Stack과 Heap을 잡음
- Heap과 Stack의 크기는 링크과정이 끝나야 알 수 있으므로, 링커가 설정 해줌
- RO의 가장 처음(0x8000)에는 `__main` 이라고 붙은 Entry point가 들어가게 됨

## Map file 분석

#### 맵파일 역할

- 메모리 주소 할당 정보 : 코드, 데이터, 스택, 힙등 각 섹션이 최종적으로 메모리의 어느 주소에 배치되었는지에 대한 정보
- 심볼 정보 : 소스 코드에 정의된 함수, 변수등의 심볼이 어느 주소에 위치되었는지에 대한 정보
- 파일 정보 : 어떤 프브젝트 파일과 라이브러리가 링킹 과정에 포함되었는지에 대한 목록 제공
- 크로스 참조 정보 : 한 심볼이 다른 심볼을 참조하는 관계에 대한 정보

#### 맵파일 구성

- 링커에 컴파일 옵션을 주면 맵파일을 생성할 수 있음
- 맵파일 안에는 이런 정보가 들어있음
  - Image Symbol Table
  - Memory Map of the image
  - Image component sizes
  - 전체 Layout

#### Image Symbol Table

- Linker가 만들어낸 Symbol과 주소 그리고 Region
- User가 만들어내 Symbol과 주소 Size 그리고 속해 있는 object

#### Memory Map of the Image

- Scatter Loading에 맞춘 Region에 따라 구획을 나누어서
- 주소와 Size, type, 그리고 Section과 object (Linker Ouput section)

#### Image component sizes

- 각 object 또는 라이브러리에 대한 RO, RW, ZI가 차지하는 Size (Linker Input section).

#### 전체 Layout

- 전체적인 Memory에 RO, RW, ZI가 얼마나 차지하는지에 대한 정보

## Makefile

> Makefile : 소프트웨어 빌드 과정 자동화 파일

#### Makefile의 주요 역할

- 빌드 자동화: 소스 코드를 컴파일, 링크, 테스트하는 일련의 과정을 명령어 스크립트로 정의합니다. 사용자는 make 명령 하나로 복잡한 빌드 과정을 쉽게 실행할 수 있습니다.
- 의존성 관리: 파일 간의 의존 관계를 명시합니다. 예를 들어, A.c 파일이 변경되면 A.o 파일만 다시 컴파일하고, 이와 관련된 최종 실행 파일만 다시 링크하도록 설정할 수 있습니다. 이를 통해 변경되지 않은 파일은 다시 빌드하지 않아 빌드 시간을 단축합니다.
- 재빌드 방지: 파일의 타임스탬프를 비교하여, 대상 파일이 의존하는 파일보다 최신이면 다시 빌드하지 않습니다. 이는 불필요한 작업을 줄여 빌드 효율성을 높입니다.

#### Makefile의 구조

Makefile은 **규칙(rule)**으로 구성되어 있습니다. 각 규칙은 다음 세 가지 요소로 이루어져 있습니다.

- 타겟(Target): 생성하고자 하는 최종 파일 (예: 실행 파일)이나 수행할 작업의 이름.
- 의존성(Prerequisites): 타겟을 생성하는 데 필요한 파일 목록.
- 명령어(Command): 타겟을 생성하기 위해 실제로 실행할 명령어.

규칙은 다음과 같은 형식으로 작성됩니다.

```
target: prerequisites
	command
```

예를 들어, hello.c 파일을 컴파일하여 hello라는 실행 파일을 만드는 간단한 Makefile 규칙은 다음과 같습니다.

```
hello: hello.o
gcc -o hello hello.o

hello.o: hello.c
gcc -c hello.c
```

아래 부분은 모두 Makefile 관련 내용으로 일단 생략
```
## 컴파일을 더더더 쉽게. MACRO와 SUFFIX
## 조금 더 Make 테크닉들
## Make Option들
````
