---
layout: single
title: "[이미지센서] MIPI CSI-2"
categories: hardware/image-sensor
---

## MIPI CSI-2

- MIPI : Moblie Industry Processor Interface, 모바일 기기 내부 부품간의 통신 표준 규격 개발 및 관리 단체
- CSI : Camera Serial Interface
- MIPI CSI에는 여러가지 버전이 있으며, 현재 MIPI CSI-2가 가장 널리 사용됨
- CSI-1은 구식 기술, CSI-3는 아직 대중화가 안됐고, 사실상 CSI-2가 대부분의 시장 요구를 충족하고 있음

## MIPI CSI-2 Layer Definition

![MIPI CSI-2 Layer Definition](https://www.panoxdisplay.com/uploadfile/images/soution/02csi_straification.jpg)

- 데이터 전송을 효율적으로 관리하기 위해 OSI 7계층 모델과 유사한 계층 구조를 가짐
- 데이터 전송은 "패킷"이라는 기본 단위를 사용함

#### PHY Layer (물리 계층)

데이터가 전기 신호로 변환되어 물리적인 선(wire)를 통해 전송되는 방식을 정의, D-PHY & C-PHY를 사용

> MIPI CSI-2의 Physical Layer는 D-PHY와 C-PHY가 있음

![D-PHY vs C-PHY](http://www.camera-module.com/upfile/2018/12/20181227154338_142.jpg)

> Lane : 데이터 전송에 사용되는 물리적인 차선

- D-PHY : 데이터 레인과 클럭 레인을 별도로 구분하여 사용
  - N개의 Data Lane : 하나의 데이터 레인이 low, high의 2가지 전압레벨을 가짐, 차동 신호 방식을 위해 2개의 wire(Data+, Data-)가 존재.
  - 하나의 Clock : 차동 신호 방식을 위해 2개의 wire(Clock+, Clock-)가 존재
  - SCL/SDA는 I2C 통신을 위한 wire, 센서외 다른 I2C Slave들도 붙어있음
- C-PHY : 클럭 레인 없이 3개의 선으로 구성된 데이터 레인만을 사용
  - N개의 Data Lane + Clock : 하나의 레인에 데이터와 클럭을 동시에 전달, 3상(3-phase) 신호라는 독특한 인코딩 방식을 위해 3개의 wire(DataA, DataB, DataC)가 존재
    - 각 wire는 low, mid, high의 3가지 전압 레벨을 가짐
    - 데이터 비트를 전압 자체에 담는 형태가 아닌 다음 순간으로 바뀌는 전압 상태의 변화에 담음
    - 클럭은 전압 상태가 전이되는 지점을 감지하여 복구하는 방식으로 이로 인해 Clock 레인이 필요 없어짐 (임베디드 클럭)
  - SCL/SDA는 I2C 통신을 위한 wire, D-PHY와 동일함

> C-PHY가 EMI(전자기 간섭)에 불리한 것 아닌가? No

- 결론 : 전류의 균형(전류 합 == 0)으로 전자기장을 효과정으로 상쇄해, D-PHY보다 낮은 EMI 특성을 보임
- C-PHY는 3개의 선에 흐르는 전류의 합을 항상 0으로 만듦
- 이로 인해 전류가 흐르지 않는 것처럼 되고, 전류에 따른 전자기장 방출도 매우 약해짐
- 클럭 레인이 없으므로 클럭 레인에서 생성되는 전자기장 방출도 작아짐

#### lane management layer : 데이터를 lane에 나누고, 모으는 계층

![lane distribution](https://i-blog.csdnimg.cn/blog_migrate/abad1119b31d0b60e8ad9ac96e21a6dd.png)

![packetInSerial](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTXdId9vdZ7lLBObigiAPrr0KedqYbqmx63Ig&s)

- MIPI CSI-2의 규격은 아니고, 이해를 위해 그림에 추가된 것으로 보임
- Serializer라는 하드웨어 IP가 전달할 데이터를 MIPI CSI-2 규격의 "데이터 스트라이핑" 규칙에 따라 각 lane에 데이터를 전송함
  - 데이터 스트라이핑 규칙 : 들어온 데이터를 순차적으로 각 레인에 할당하도록 정의됨

#### Protocol Layer (프로토콜 계층 : low level protocol) : 전송 규칙 정의 및 패킷 구성

- 전송 규칙 정의 : 데이터를 어떻게 전송할지 Serializer(Hardware IP)를 세팅함
- 패킷 : 데이터 전송의 기본 단위, 크게 Short packet과 Long packet으로 나뉨
  - Short Packet : 컨트롤 신호
  - Long Packet : 실제 픽셀 데이터가 담김

#### Long Packet

![Long Packet](https://xilinx.file.force.com/servlet/servlet.ImageServer?id=0152E000003pG2pQAE&oid=00D2E000000nHq7)

- LPS : Low Power State
- SoT : Start of Transmission
- EoT : End of Transmission
- Packet Header
  - Data ID (8bits) : VC(2bits : 4개의 채널 지원) + Data Type(6bits)
  - Word Count (16bits) : Packet Data의 갯수
  - VCX + ECC (8bits) : VCX(2bits : Virtual Channel Extension) + ECC(6bits)
- Packet Data : 실제 픽셀 데이터 (8bits \* Word Count)
- Packet Footer : Checksum/CRC

#### 일반적인 Virtual Channel과 Data Type의 역할

- Virtual Channel : 하나의 MIPI CSI-2 링크에 여러 개의 카메라 센서가 연결된 경우, 데이터가 어떤 소스에서 왔는지 알려줌. (VC0 : 전면 카메라, VC1 : 후면 카메라 구분)
- Data Type : 패킷의 내용을 구분, (0x24 : YUV422 포맷의 픽셀 데이터, 0x12 : 임베디드 데이터)

#### Short Packet

![Short Packet](https://huiminee.wordpress.com/wp-content/uploads/2016/10/short-packet-format.png)

- Packet Header
  - Data ID (8bits) : VC(2bits : 4개의 채널 지원) + Data Type(6bits)
  - Word Count : Short packet Data field로 사용됨
  - Short pakcet Data field 안에 내용 : 각 Data type에 따라 다른 용도로 사용, 아래 데이터 타입에서 더 자세히 다룸
- Packet Data : 존재하지 않음
- Packet Footer : 존재 하지 않음

Short Packet Data Type Code
![Short Packet Data Type Code](https://huiminee.wordpress.com/wp-content/uploads/2016/10/short-packet-data-type.png)

> Short Packet과 Long Packet의 구분은 Data Type으로 가능함. (Shor Packet은 0x00 ~ 0x0F까지의 Data Type을 가짐)

- Frame Start/End code : 프레임의 시작과 끝을 알림
  - Word Count(Short Packet Data Field) : 16bits 프레임번호가 들어감
  - 특정 프레임에 해당하는 FS 패킷과 FE 패킷은 동일한 프레임 번호를 가져야 함
- Line Start/End code (optional): 라인의 시작과 끝을 알림
  - Word Count(Short Packet Data Field) : 16bits 라인 번호가 들어감
  - 특정 라인에 해당하는 LS 패킷과 LE 패킷은 동일한 라인 번호를 가져야함
  - 이 라인 번호는 물리적인 라인 번호와 반드시 같을 필요는 없는 논리적인 번호임
  - 수신기(Receiver)는 블랭킹 기간을 아는게 중요함 (프레임 블랭킹 기간 + 라인 블랭킹 기간)
  - 블랭킹 기간동안 하드웨어를 저전력 모드로 전환하거나 다음 데이터 수신을 위한 준비 시간을 가짐
  - 수신기 입장에서 LE가 들어오면 라인 블랭킹 기간이 시작되고, LS가 들어오면 라인 블랭킹 기간 끝났음을 알 수 있음
  - 수신기는 거의 0에 가까운 라인 블랭킹 기간도 처리할 수 있어야함
  - 롤링 셔터 방식이 아닌 글로벌 셔터 방식에서는 라인별로 나오지 않아 굳이 필요없음

#### RAW10 Transmission 예

![RAW10 Transmission](https://huiminee.wordpress.com/wp-content/uploads/2016/10/raw10-transmission.png)
![RAW 10 Frame Format](https://huiminee.wordpress.com/wp-content/uploads/2016/10/raw10-frame-format.png)

- 10bit를 8bit + 2bit로 쪼갠후, 각 픽셀의 8bit + 4개의 픽셀의 2bit를 하나로 합친 8bit로 만들어 보냄
- FS, FE는 Short packet
- PH + ... + PF가 Long packet

#### python으로 표현한 롤링 셔터 방식의 패킷 전송 흐름

```python
send(frame_start_packet)

for (line in lines):
    send(line_start_packet) # optional
    for (long_packet in line_data): # 한 라인의 데이터는 여러 개의 Long Packet으로 나뉠 수 있음
        send(long_packet)
    send(line_end_packet) # optional

send(frame_end_packet)
```

#### 임베디드 데이터

- 임베디드 데이터는 데이터 타입으로 구분함
  - 0x12 : Embedded Non-Image Data
  - 0x30~0x37 : User Defined Data
- 보통 임베디드 데이터는 수직 블랭킹 기간 동안 전송됨 (앞쪽에 붙여도 되긴함)

#### Data interleave

Data interleave : 여러가지 데이터 타입을 번갈아 가며 보내는 것, MIPI CSI-2에서 직접 사용되는 용어는 아닌듯

![packet level data interleave](https://i-blog.csdnimg.cn/blog_migrate/9cf0530fc4d4d0ef333a43c341334d4d.png)

- 패킷 레벨 인터리빙 : 하나의 fs/fe 안에 다른 종류의 데이터 타입의 data를 보냄
  - 다른 종류의 데이터 타입도 하나의 데이터 타입 다 보내고 다른 데이터 타입을 보내는 방법도 있고
  - 다른 종류의 데이터 타입을 번갈아 가면서 보내는 방법도 있음

![frame level data interleave](https://i-blog.csdnimg.cn/blog_migrate/5f37185f72b1db6142f0e778e74c69a3.png)

- 프레임 레벨 인터리빙 : 데이터 타입별 fs/fe를 구분하여 보내는 방식
  - 예. fs/fe 안에 하나의 데이터 타입 보내고, 또 다음 fs/fe에는 다른 데이터 타입을 보내는 방식

![](https://i-blog.csdnimg.cn/blog_migrate/e3094eb481926eceb51dbf905795d07e.png)

> 위 그림을 보면 무조건 데이터 타입1, 데이터 타입2 돌아가는건 아니고, 정의하기 나름인듯

#### Virtual Channel + Embedded Data + Interleave Data

![](https://i-blog.csdnimg.cn/blog_migrate/fe0d4d452825ff30ff5de80c34fd9a9b.png)

- 하나의 mipi line에서 VC, Interleave Data를 하기 위해 이런식으로 serialize가 됨
- 각 Virtual Channel은 FS/FE를 따로 가짐
