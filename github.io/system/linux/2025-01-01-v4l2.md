---
layout: single
title: "[linux] 이미지 센서 디바이스 드라이브 Overview"
categories: system/linux
---

## V4L2

- V4L2 : Video 4 Linux 2, 비디오 장치 제어를 위한 커널 인터페이스
- 비디오 스트리밍, 장치 제어등 지원
- 디바이스 파일 : /dev/videoX (X : 장치 번호)

#### 주요 개념

- 디바이스 파일 : `/dev/videoX`
- IOCTL : ioctl로 제어
- 버퍼링 : V4L2는 비디어 프레임을 메모리 버퍼에 저장하고, 이 버퍼에서 프레임을 가져오는 방식으로 동작함. 주로 mmap이나 userptr 같은 버퍼링 방식을 사용
- `v4l2-utils` 패키지에 포함된 `v4l2-ctl`을 사용하면 카메라 정보 확인이나 설정 변경이 가능함.
  - `v4l2-ctl`은 내부적으로 파일 open 및 ioctl 호출함

#### V4L2 스트리밍 과정

1. 비디오 캡처를 위한 버퍼를 드라이버에게 요청하여 할당 받음
2. 해당 버퍼들을 드라이버의 준비 큐에 enque 함.
3. 스트리밍이 시작되면, 드라이버는 준비 큐에서 버퍼를 deque하고, 해당 버퍼에 프레임 캡처 데이터를 쓰고, 완료 버퍼에 enque함
4. 사용자가 완료 버퍼를 deque하여 데이터를 확인하고 처리하고, 다 사용한 버퍼는 다시 드라이버의 준비 큐에 enque함.

스트리밍을 종료하면 다 프레임 캡처가 더이상 진행되지 않고, 큐에 남아있던 모든 버퍼가 비워짐

## 주 사용 ioctl

- 장치 정보 확인 및 초기 설정
  - VIDIOC_QUERYCAP : 디바이스의 전체 기능 및 장치 종류, 버퍼링방식(mmap, userptr등)등
  - VIDIOC_ENUM_FMT : 디바이스가 지원하는 픽셀 포맷 열거
  - VIDIOC_S_FMT & VIDIOC_G_FMT: 픽셀 포맷 및 해상도 설정 & 확인
- 버퍼 관리 및 스트리밍
  - VIDIOC_REQBUFS : 비디오 데이터를 저장할 버퍼 요청
  - VIDIOC_QUERYBUF : 요청된 버퍼에 대한 상세 정보 확인
  - VIDIOC_QBUF : 버퍼를 큐에 등록
  - VIDIOC_DQBUF : 버퍼를 큐에서 빼냄
  - VIDIOC_STREAMON & VIDIOC_STREAMOFF : 비디오 스트리밍 시작 & 중단
- 기타 설정 및 제어
  - VIDIOC_S_PARAM & VIDIOC_G_PARAM : 스트리밍 파라미터 설정 & 확인
  - VIDIOC_QUERAYCTRL : 컨트롤 종류 enumerate 형태 조회
  - VIDIOC_S_CTRL & VIDIOC_G_CTRL : 특정 컨트롤의 값 설정 & 확인

#### VIDIOC_QUERYCAP : 해당 디바이스 노드가 어떤 장치인지, 또 스트리밍, read/write를 지원하는지 알기 위해 사용

```c
struct v4l2_capability {
    __u8    driver[16];     /* 드라이버 이름 (예: "uvcvideo") */
    __u8    card[32];       /* 카드 이름 (예: "Logitech HD Webcam C920") */
    __u8    bus_info[32];   /* 버스 정보 (예: "usb-0000:00:14.0-3") */
    __u32   version;        /* 드라이버 버전 */
    __u32   capabilities;   /* 장치의 기능 플래그 */
    __u32   device_caps;    /* 장치 파일에 특화된 기능 플래그 */
    __u32   reserved[3];    /* 향후 확장을 위한 예약 필드 */
};

struct v4l2_capability cap;

ioctl(fd, VIDIOC_QUERYCAP, &cap);
```

- driver : 드라이버 이름, 보통 커널 모듈의 이름과 일치
- card : 실제 장치의 이름, 사용자가 알아보기 쉬운 이름
- bus_info : 장치가 연결된 버스에 대한 정보
- version : 드라이버 버전 정보
- capabilities : 장치가 지원하는 기능을 비트 마스크 형태로 나타냄
  - V4L2_CAP_VIDEO_CAPTURE : 비디오 캡처 장치인지 여부 (카메라, 캠코더 등)
  - V4L2_CAP_VIDEO_OUTPUT : 비디오 출력 장치인지 여부 (모니터, 프로젝터, TV 등)
  - V4L2_CAP_STREAMING : 스트리밍 I/O (mmap 또는 userptr)를 지원하는지 여부
  - V4L2_CAP_READWRITE : read()/write() 함수를 지원하는지 여부
- device_caps : 디바이스 드라이버가 제공하는 특정 장치 노드에 대한 기능을 나타내는 비트 마스크
  - V4L2는 하나의 물리적인 장치가 여러 기능을 가질 때, 각 기능별로 다른 디바이스 노드를 생성하도록 설계됨
  - 물리적인 장치가 여러 개의 디바이스 노드를 가질 수 있음
  - 각 노드마다 제공하는 기능이 다를 수 있고 그걸 지원하기 위함
  - capabilities에는 모든 노드가 지원하는 cap을 넣고, device_caps에 각 디바이스 노드가 제공하는 기능을 따로 넣기위해 만들어짐

#### VIDIOC_ENUM_FMT : 해당 디바이스 노드가 지원하는 픽셀 포맷을 enumerate

```c
struct v4l2_fmtdesc {
  __u32               index;
  __u32               type;
  __u32               flags;
  __u8                description[32];
  __u32               pixelformat;
  __u32               reserved[4];
};

for(__u32 i = 1; ; i++) {
  memset(&fmtdesc, 0, sizeof(fmtdesc));
  fmtdesc.index = i;
  fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

  if (ioctl(fd, VIDIOC_ENUM_FMT, &fmtdesc) < 0) { // 더 이상 지원 포맷이 없으면 루프 종료
      break;
  }

  // 결과 출력
  printf("%d: %s (fourcc: %c%c%c%c)\n",
          fmtdesc.index,
          fmtdesc.description,
          (fmtdesc.pixelformat >> 0) & 0xFF,
          (fmtdesc.pixelformat >> 8) & 0xFF,
          (fmtdesc.pixelformat >> 16) & 0xFF,
          (fmtdesc.pixelformat >> 24) & 0xFF);
}
```

- 디바이스가 지원하는 픽셀 포맷을 enumerate (하나씩 검색)하는 형태로 제공
- 더이상 지원하는 포맷일 없을 경우, `-EINVAL`이 반환되며 검색을 중지
- fmtdesc.index를 설정한 후, ioctl을 호출
- index : 호출마다 증가시키는 포맷 번호
- type : 버퍼 유형, 캡처 장치는 `V4L2_BUF_TYPE_VIDEO_CAPTURE`를 사용
- flags : 현재는 두 가지 플래그가 사용되고 있음
  - `V4L2_FMT_FLAG_COMPRESSED` : 해당 포맷이 압축된 포맷이라는 것을 의미 (예. JPET, H.264 포맷)
  - `V4L2_FMT_FLAG_EMULATED` : 하드웨어가 직접 지원하는 것이 아닌 소프트웨어적으로 에뮬레이션된 포맷, 드라이버가 하드웨어 포맷을 소프트웨어로 변환하여 제공할 때 사용
- descrption : 사람이 읽을 수 있는 포맷 이름 (예. "YUYV 4:2:2")
- pixelformat : 4글자 코드(Four CC)로 된 픽셀 포맷 식별자 (예. `V4L2_PIX_FMT_YUYV`)

#### VIDIOC_S_FMT : 픽셀 포맷 및 해상도 설정

```c
struct v4l2_format {
    __u32 type; // 버퍼 유형 (예: V4L2_BUF_TYPE_VIDEO_CAPTURE)
    union {
        struct v4l2_pix_format      pix;        // 비디오 캡처/출력 포맷
        struct v4l2_pix_format_mplane pix_mp;  // 멀티플레인 비디오 캡처/출력 포맷
        struct v4l2_vbi_format      vbi;        // VBI 포맷
        struct v4l2_sliced_vbi_format sliced;   // 슬라이스 VBI 포맷
        __u8 raw_data[200];                   // 기타 포맷
    } fmt;
};

struct v4l2_format fmt;
memset(&fmt, 0, sizeof(fmt));
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
fmt.fmt.pix.width = 640;
fmt.fmt.pix.height = 480;
fmt.fmt.pix.pixelformat = V4L2_PIX_FMT_YUYV;
fmt.fmt.pix.field = V4L2_FIELD_INTERLACED;

ioctl(fd, VIDIOC_S_FMT, &fmt);
```

#### VIDIOC_G_FMT : 현재 설정된 픽셀 포맷 및 해상도 확인

```c
struct v4l2_format fmt;
memset(&fmt, 0, sizeof(fmt));
fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

ioctl(fd, VIDIOC_G_FMT, &fmt);
```

#### VIDIOC_REQBUFS & VIDIOC_QUERYBUF & mmap: 드라이버에게 버퍼 할당을 요청 & 버퍼 정보 확인 및 매핑

```c
struct v4l2_requestbuffers {
    __u32                 count;
    __u32                 type;
    __u32                 memory;
    __u32                 capabilities;
    __u32                 reserved[1];
};

struct v4l2_requestbuffers reqbuf;

memset(&reqbuf, 0, sizeof(reqbuf));
reqbuf.count = 4;                           // 버퍼 4개 요청
reqbuf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; // 비디오 캡처용 버퍼
reqbuf.memory = V4L2_MEMORY_MMAP;          // mmap 방식으로 메모리 할당

ioctl(fd, VIDIOC_REQBUFS, &reqbuf);
```

위에 부분이 끝나면, 드라이버 내부적으로 버퍼 할당이 끝난 상태이고, 해당 버퍼 정보들을 사용자가 알기 위해서는 `VIDIOC_QUERYBUF`를 사용하고, 이를 mmap을 통해 사용자 공간에 매핑해놓음

```c
struct v4l2_buffer {
    __u32                 index;
    __u32                 type;
    __u32                 bytesused;
    __u32                 flags;
    __u32                 field;
    struct timeval        timestamp;
    struct v4l2_timecode  timecode;
    __u32                 sequence;

    /* memory location */
    __u32                 memory;
    union {
        __u32             offset;
        unsigned long     userptr;
        struct v4l2_plane *planes;
        __s32             fd;
    } m;

    __u32                 length;
    __u32                 reserved2;
    __u32                 reserved;
};

struct buffer { // 버퍼 매핑 정보를 담을 구조체
    void   *start;
    size_t length;
};

struct buffer buffers[4]; // 4개 버퍼 요청시 4개의 매핑 정보를 위해 크기를 4로 설정

for (int i = 0; i < reqbuf.count; ++i) {
    struct v4l2_buffer buf;
    memset(&buf, 0, sizeof(buf));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = i;

    // VIDIOC_QUERYBUF: 각 버퍼의 상세 정보를 가져옴
    if (ioctl(fd, VIDIOC_QUERYBUF, &buf) < 0) {
        perror("VIDIOC_QUERYBUF failed");
        close(fd);
        return 1;
    }

    // mmap: 버퍼를 애플리케이션 메모리 공간에 매핑
    buffers[i].length = buf.length;
    buffers[i].start = mmap(NULL, buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd, buf.m.offset);

    if (MAP_FAILED == buffers[i].start) {
        perror("mmap failed");
        close(fd);
        return 1;
    }
    printf("Buffer %d mapped at address %p\n", i, buffers[i].start);
}
```

#### VIDIOC_QBUF : 드라이버의 준비 큐에 버퍼 넣기

```c
for (int i = 0; i < reqbuf.count; ++i) {
    struct v4l2_buffer buf;
    memset(&buf, 0, sizeof(buf));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = i;

    // VIDIOC_QBUF: 버퍼를 드라이버의 큐에 추가
    if (ioctl(fd, VIDIOC_QBUF, &buf) < 0) {
        perror("VIDIOC_QBUF failed");
        close(fd);
        return 1;
    }
}
```

#### VIDIOC_STREAMON & VIDIOC_STREAMOFF : 스트리밍 시작 & 스트리밍 종료

```c
enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

// 스트리밍 시작
if (ioctl(fd, VIDIOC_STREAMON, &type) < 0) {
    perror("VIDIOC_STREAMON failed");
    close(fd);
    return 1;
}

// 캡처 데이터 n회 처리

// 스트리밍 종료
if (ioctl(fd, VIDIOC_STREAMOFF, &type) < 0) {
        perror("VIDIOC_STREAMOFF failed");
    }
    printf("Streaming stopped.\n");
```

#### VIDIOC_DQBUF : 프레임이 채워진 버퍼를 완료 큐에서 빼오기

```c
while (1) {
    struct v4l2_buffer buf;
    struct pollfd pfd = { .fd = fd, .events = POLLIN };

    memset(&buf, 0, sizeof(buf));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;

    // poll: 버퍼가 준비될 때까지 기다림, 이벤트가 발생할 때까지 불필요한 CPU사용을 막고 효율적으로 대기함
    if (poll(&pfd, 1, -1) < 0) {
        perror("poll failed");
        break;
    }

    // VIDIOC_DQBUF: 프레임이 채워진 버퍼를 큐에서 가져옴
    if (ioctl(fd, VIDIOC_DQBUF, &buf) < 0) {
        perror("VIDIOC_DQBUF failed");
        break;
    }
    printf("Frame %d captured (buffer index: %d)\n", i, buf.index);

    // 여기서 버퍼(buffers[buf.index].start)의 데이터를 처리
    // ...

    // VIDIOC_QBUF: 처리 완료 후 버퍼를 다시 큐에 반납
    if (ioctl(fd, VIDIOC_QBUF, &buf) < 0) {
        perror("VIDIOC_QBUF failed");
        break;
    }
}
```

#### VIDIOC_S_PARAM & VIDIOC_G_PARAM : 파라미터 설정 & 파라미터 확인

```c
struct v4l2_fract { // 30 fps : numeratore=1, denominator=30
    __u32   numerator;   /* 분자 */
    __u32   denominator; /* 분모 */
};

struct v4l2_captureparm {
    __u32                 capability; // 위에서 본 capability와 같음
    __u32                 capturemode; // 여러 가지 캡처 모드(예. 고속/저속 캡처모드, 야간 촬영모드, 외부신호트리거캡처)등을 지원시 사용, 아니면 그냥 0으로 둠
    struct v4l2_fract     timeperframe; // 시간당 프레임을 나타냄
    __u32                 extendedmode; // 확장된 캡처 모드를 위한 필드, 드라이버마다 특정 기능을 커스텀 정의
    __u32                 reserved[2];
};

struct v4l2_streamparm {
    __u32                 type;
    union {
        struct v4l2_captureparm  capture; // type이 V4L2_BUF_TYPE_VIDEO_CAPTURE일때, 이걸로 사용
        struct v4l2_outputparm   output;
        __u8                     raw_data[200];
    } parm;
};

struct v4l2_streamparm stream_parm;
memset(&stream_parm, 0, sizeof(stream_parm));
stream_parm.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
ioctl(fd, VIDIOC_G_PARAM, &stream_parm);

ioctl(fd, VIDIOC_S_PARAM, &stream_parm);
```

#### VIDIOC_QUERAYCTRL : 디바이스 노드가 지원하는 control 정보를 열거 형태로 조회

```c
struct v4l2_queryctrl {
    __u32                     id; // V4L2_CID_BRIGHTNESS (밝기), V4L2_CID_CONTRAST(대비) 등 미리 정의된 ID가 있음
    __u32                     type; // 컨트롤의 데이터 타입, V4L2_CTRL_TYPE_INTEGER, V4L2_CTRL_TYPE_BOOLEAN 등이 존재
    __u8                      name[32]; // 사람이 읽을 수 있는 이름
    __s32                     minimum; // 컨트롤의 최소 값
    __s32                     maximum; // 컨트롤의 최대 값
    __s32                     step; // 증감 변경 단위
    __s32                     default_value; // 기본 값
    __u32                     flags; // 속성을 나타내는 비트 마스크, V4L2_CTRL_FLAG_DISABLED(비확성화), V4L2_CTRL_FLAG_SLIDER(슬라이더표시적합)등 존재
    __u32                     reserved[2];
};

struct v4l2_queryctrl qctrl;
memset(&qctrl, 0, sizeof(qctrl));
qctrl.id = V4L2_CID_USER_BASE; // 사용자 정의 컨트롤의 시작 ID

while (ioctl(fd, VIDIOC_QUERYCTRL, &qctrl) == 0) {
    printf("  ID: 0x%08X\n", qctrl.id);
    printf("  Name: %s\n", qctrl.name);
    printf("  Type: %s\n", get_control_type_string(qctrl.type));

    // 컨트롤 타입에 따라 추가 정보 출력
    if (qctrl.type == V4L2_CTRL_TYPE_INTEGER ||
        qctrl.type == V4L2_CTRL_TYPE_INTEGER64 ||
        qctrl.type == V4L2_CTRL_TYPE_MENU ||
        qctrl.type == V4L2_CTRL_TYPE_INTEGER_MENU) {
        printf("  Range: %d to %d (Step: %d)\n", qctrl.minimum, qctrl.maximum, qctrl.step);
        printf("  Default Value: %d\n", qctrl.default_value);
    } else if (qctrl.type == V4L2_CTRL_TYPE_BOOLEAN) {
        printf("  Default Value: %s\n", qctrl.default_value ? "True" : "False");
    }

    // 플래그 정보 (일부만 예시로 출력)
    printf("  Flags: ");
    if (qctrl.flags & V4L2_CTRL_FLAG_DISABLED) printf("DISABLED ");
    if (qctrl.flags & V4L2_CTRL_FLAG_GRABBED) printf("GRABBED ");
    if (qctrl.flags & V4L2_CTRL_FLAG_UPDATE) printf("UPDATE ");
    if (qctrl.flags & V4L2_CTRL_FLAG_INACTIVE) printf("INACTIVE ");
    printf("\n");

    printf("----------------------------------------\n");

    // 다음 컨트롤을 쿼리하기 위해 ID를 업데이트
    // V4L2_CTRL_FLAG_NEXT_CTRL 플래그는 V4L2_CID_PRIVATE_BASE 이후 컨트롤을 탐색할 때 사용될 수 있습니다.
    // 여기서는 VIDIOC_QUERYCTRL이 자동으로 다음 ID를 반환하므로 명시적으로 설정하지 않아도 됩니다.
    // 일반적으로는 'qctrl.id |= V4L2_CTRL_FLAG_NEXT_CTRL;' 형태로 다음 컨트롤을 탐색하지만,
    // 현재 예시에서는 V4L2_CID_USER_BASE부터 시작하여 모든 컨트롤을 순회하도록 합니다.
    // V4L2_CID_LAST_EXT_CTRL + 1 로 설정하여 모든 V4L2 정의 컨트롤을 순회할 수도 있습니다.
    qctrl.id++; // 다음 ID로 이동 (간단한 예시)
}
```

#### VIDIOC_S_CTRL & VIDIOC_G_CTRL : 특정 컨트롤의 값 설정 & 확인

```c
struct v4l2_control {
    __u32   id;    /* 컨트롤 ID */
    __s32   value; /* 컨트롤 값 */
};

struct v4l2_control ctrl;

// 현재 밝기 값 가져오기 (VIDIOC_G_CTRL)
memset(&ctrl, 0, sizeof(ctrl));
ctrl.id = V4L2_CID_BRIGHTNESS; // 밝기 컨트롤 ID

if (ioctl(fd, VIDIOC_G_CTRL, &ctrl) < 0) {
    perror("VIDIOC_G_CTRL for BRIGHTNESS failed");
    close(fd);
    return 1;
}
printf("Current Brightness: %d\n", ctrl.value);

// 밝기 값 설정 (VIDIOC_S_CTRL)
int new_brightness = ctrl.value + 10;

// VIDIOC_QUERYCTRL을 통해 얻은 min/max 범위 내에서 값을 설정하는 것이 안전합니다.
// 여기서는 간단히 예시로 +10만 합니다.
ctrl.value = new_brightness;

if (ioctl(fd, VIDIOC_S_CTRL, &ctrl) < 0) {
    perror("VIDIOC_S_CTRL for BRIGHTNESS failed");
    close(fd);
    return 1;
}
printf("Attempted to set Brightness to: %d\n", new_brightness);
```
