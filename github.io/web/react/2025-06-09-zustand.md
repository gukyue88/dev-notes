---
layout: single
title: "[React] Zustand"
categories: web/react
---

#### zustand란?

- 전역 상태 관리 라이브러리
- 작고 빠르고 확장 가능함
- 다른 전역 상태 관리 라이브러리와는 다르게 Provider 를 사용하지 않음

#### 전역 상태 관리가 필요한 이유?

- 전역 상태 관리가 없는 경우
  - Prop Drilling : 여러 컴포넌트가 동일한 데이터를 공유해야 하는 경우, `props`를 통해 상태를 전달해야함
    - 이 구조가 복잡하고 유지 보수를 어렵게 만듦
    - 해당 state를 사용하지 않는 컴포넌트들도 전달에 참여해야함
  - state 변경이 여기저기에서 일어나면 누가 변경했는지 알기 어려워 동작 예측과 버그 발생 원인을 찾기 힘들어짐
  - state 중 일부만 변경됐을 때에 대한 처리 로직(훅의 의존성을 통해 구분)이 컴포넌트쪽 로직에 들어가 컴포넌트의 코드 복잡도가 올라감 (컴포넌트는 가능하면 viewing 로직만 들어가는 것이 더 깔끔함)
- 전역 상태 관리 : 상태 관리를 컴포넌트 바깥에서 **한 곳**에 모아 관리
  - 해당 state를 사용하는 컴포넌트들만 관여
  - **한 곳**에서 상태 변경을 관리(상태를 직접 변경하는 것이 아닌 중앙 관리체에게 변경해달라고 부탁)하면서 누가 언제 변경했는지 알게되면서 동작 예측과 버그 발생 원인을 찾기 쉬워짐.
  - state 중 일부만 구독 가능해지면서 컴포넌트쪽 로직이 간단해짐

#### 동작 방식

> state를 한 곳에 모으고, **중앙 관리체인 `store`를 통해서만** state를 변경하거나 state를 구독함

![store를 사용한 state 관리](https://somwpkzlplaovldnfahk.supabase.co/storage/v1/object/public/heropy.dev_posts/n74Tgc/s5.png)

```
state <-> store <-> components
```

- 여러 컴포넌트가 데이터를 공유해야하는 경우, `props`를 통해 하위 컴포넌트로 상태를 전달하는 복잡한 코드 구조(Prop Drilling)를 사용하지 않아도 됨
- state 변경시 store를 통해야하므로 store에서 언제 어디서 누가 state를 변경했는지 추적할 수 있음
- component가 state 변경 요청을 하면 store가 해당 state를 구독하는 component에게 알리는 단방향 데이터 흐름을 만들 수 있음 (데이터 변경요청 -> store -> 구독중인 컴포넌트에게 알림)
- state를 일부만 구독할 수 있는 `선택적 구독 로직`을 store쪽에서 제공하여, 컴포넌트쪽의 일부만 구독하기 위한 훅 로직을 제거할 수 있음 (컴포넌트 코드가 viewing 로직에 좀 더 집중할 수 있음)

#### 핵심 구조

> `store`라는 것은 특정 객체가 아니라, state의 직접 접근은 막고, state를 변경 및 구독을 관리하는 **추상적인 개념**임

```
         selector
            ↓
┌----- useCountStore -----┐
|                         |
| ┌------ closure ------┐ |
| |                     | |
| |    get()   set()    | |
| |      ↑       ↓      | |
| | ┌----- state -----┐ | |
| | |  count          | | |
| | |  increase()     | | |
| | └-----------------┘ | |
| └---------------------┘ |
└-------------------------┘
            ↓
    selectedState/Action
```

다음은 `count`라는 상태와 `increase`라는 `count`를 증가시키는 요청 함수(액션)을 지원하는 `useCountStore` 함수(hook)의 구조를 간략화한 것이다.

- zustand의 `create` 함수는 React 컴포넌트에서 상태를 구독하고 변경할 수 있는 커스텀 Hook(예제. `useCountStore` 함수)를 return 한다.
- Hook 안에 클로저 공간은 함수의 스코프와 관계없이 데이터를 유지하며, 함수 안에서만 데이터 접근이 가능하다.
  - 이를 통해 state의 직접 접근을 막으면서, 함수의 스코프와 관계없이 state를 유지할 수 있다.
- `get()` : `state`를 읽는데 사용하는 `useCountStore`의 내부 함수
- `set()` : `state`를 변경하는데 사용하는 `useCountStore`의 내부 함수
- `state` : 상태와 액션이 담긴 객체 (`zustand`는 state 안에 상태와 액션을 모두 담는 구조를 사용한다.)

#### 패키지 설치

```bash
npm install zustand
```

#### useCountStore 생성

stores/countStore.ts

```ts
const useCountStore = create((set, get) => {
  return {
    count: 10,
    increase: () => {
      set((state) => state.count + 1);
    },
  };
});
```

- `create` 함수는 콜백함수를 인자로 받는다.
- 이 `create` 함수에 전달되는 콜백함수는 `useCountStore` 내부 함수인 `set`과 `get`를 매개변수로 한다.
- 이 `create` 함수에 전달되는 콜백함수는 `state` 안에 담길 초기 상태(`count`)와 액션(`increase`)을 담은 객체를 return 한다.
  - 액션은 매개변수로 넘겨받은 `useCountStore`의 `get`, `set` 함수를 사용하여 상태를 변경하도록 정의한다.
    - `set`은 상태를 변경할 때 사용하며, `get`은 상태 변경 전 상태를 먼저 확인해야할 경우 사용한다.
- `create` 함수는 `useCountStore` 함수 (Hook)을 return 한다.

#### useCountStore 사용

```ts
const count = useCountStore((state) => state.count);
const increase = useCountStore((state) => state.increase);
const isCountOver10 = useCountStore((state) => state.count > 10);

const { count, increase } = useCountStore();
```

- `useCountStore` 함수는 콜백함수(selector)를 인자로 받는다.
- selector를 사용하면 `state` 중 관심이 있는 상태만 가져올 수 있다.
- 또, selector를 사용하면 특정 상태에 의존하여 함께 변화되는 또 다른 상태를 생성할 수 있다.
- `useCountStore` 함수는 선택된 상태나 선택된 액션을 return 한다.
- selector가 없는 경우, 전체 `state`를 return하고, 이를 구조 분해 할당하여 사용하는 패턴도 자주 사용된다.

#### 참고자료

- https://www.heropy.dev/p/n74Tgc
- https://www.youtube.com/watch?v=zNHZJ_iEMPA
