# Poky

- Poky는 기본적인 리눅스 스택 빌드가 되도록 Yocto가 배포한 참고용 배포판임
- 커스텀스리눅스를 구축하고 빌드하는 것은 복잡함
- Poky 내에는 스텀 리눅스를 쉽게 구축하고 빌드할 수 있는 메타데이터들이 존재함
- 이 메타데이터들을 기반으로 필요한 메타데이터를 추가 변경함으로써 커스텀 리눅스를 구축하고 빌드함
- Yocto 프로젝트는 단일 프로젝트가 아님.
- Poky는 여러 프로젝트 중 하나이며, Poky를 이해한다는 것은 bitbake와 오픈임베디드 코어를 이해한다는 것과 같음

#### Poky의 구조

Poky의 구조는 계층형(layered) 아키텍처로 되어있음

```
- meta (oe-core) : 리눅스 배포판을 생성하기 위한 도구, 메타데이터들로 구성된 빌드 프레임워크
- meta-poky : yocto에서 제공되는 Poky 참조 배포에 대한 메타데이터가 존재
- meta-yocto-bsp : yocto에서 제공되는 참조 bsp 관련 메타데이터가 존재
- other layers : 필요에 따라 추가된 레이어, 이 부분을 개발자가 추가하는 레이어
```

> 앞으로 Poky를 빌드 시스템 관점에서 말할 때 오픈임베디드 빌드 시스템이라고 부를 것임

- 다운로드 받은 Poky 소스에는 bitbake를 포함한 여러 편리한 스크립트들, 다양한 툴, 오픈임베디드 코어, 참조 메타데이터들이 들어있음
- 오픈 임베디드 빌드 시스템은 "bitbake" + "오픈 임베디드 코어"를 뜻하는 용어임
- Yocto와 관련된 이름은 음식과 관련된 것이 많고, Poky도 초콜릿 과자에서 이름을 따왔는데 Pocky라는 이름을 그대로 사용하면 문제가 되서 Poky로 사용함

## 오픈 임베디드

- 오픈임베디드란? 임베디드 장치용 리눅스 배포판을 만드는 데 사용되는 빌드 자동화 프레임워크 및 크로스 컴파일러 환경
  - 레시피를 사용해 소스 코드를 저장소에서 가져오고 필요할 경우 패치를 적용하며 소스 코드를 컴파일 및 링크하고 패키지 및 부팅이 가능한 이미지를 생성함
- Poky에서 가장 핵심적인 역할을 하는 레이어 == meta 레이어
- meta 레이어는 다른 말로 `오픈 임베디드 코어` 라고 부름
- 오픈 임베디드 코어를 줄여서 `oe-core`라고도 부르기도 함
- 권장하는 빌드 시스템으로는 빌드 도구인 bitbake를 사용하고, bitbake는 레시피를 기반으로 빌드를 진행함

#### 오픈임베디드 레이어 vs 오픈임베디드 코어 레이어

- 오픈임베디드 레이어는 `meta-openembedded` 디렉터리임
- 오픈임베디드 코어 레이어는 `meta` 디렉터리임
- 오픈 임베디드 프로젝트 초기에 레시피들의 집합은 `meta-openembedded`에 모두 포함되어 있었으나, 점점 크기가 커지면서 문제가 되었음.
- 그래서 레시피들을 유용하고 유지관리하기 쉽게 분할하기 시작했으며, 오픈임베디드 코어가 나오게 됨
- 오픈 임베디드 코어에는 작고 유용한 임베디드 장치를 구한하는데 필요한 레시피들을 모아놓음

## Poky 소스를 다운로드하고 빌드 실행

#### Poky 소스 클론

```bash
git clone git://git.yoctoproject.org/poky
cd poky_src
git checkout dunfell # dunfell 브랜치로 체크아웃
```

#### Poky 디렉터리 구조

```
- poky_src
  - poky
    - bitbake
    - contrib
    - documentation
    - meta : 오픈 임베디드 코어 레이어
    - meta-poky : Yocto 배포 참조 레이어
    - meta-selftest : oe-selftest 스크립트가 사용하는 bitbake 테스트 레이어
    - meta-yocto-bsp : 커스텀 레이어를 생성하는 데 사용되는 템플릿 레이어
    - scripts : Yocto 프로젝트의 bsp 레이어
```

- Poky 내부에는 오픈임베디드 빌드 시스템인 빌드 도구 bitbake와 오픈임베디드 코어가 존재하며 참고를 위한 다른 메타데이터들도 존재함

#### Poky 소스 빌드

```bash
source poky/oe-init-build-env # 빌드 환경 초기화 스크립트 실행, 빌드에 필요한 셀 환경 변수 설정
bitbake core-image-minimal -k
```

- `core-image-minimal`은 레시피 파일의 이름임
- `core-image-minimal` 레시피 파일은 Poky에서 배포된 것으로 빌드 이후 타깃 머신(여기에서는 QEMU)에 부팅되도록 지원하는 이미지를 얻을 수 있음
- `-k` 옵션은 빌드 중 에러가 발생하더라도 끝까지 빌드를 계속하라는 옵션임
- 장치를 부팅하면 간단한 명령행 프롬프트와 함께 로그인 화면이 뜨는 것을 볼 수 있음
- 오픈임베디드 코어는 다양한 예제 이미지들을 생성하는 레시피 파일들을 포함함
  - 명령행 프로프트만 나오는 장치부터 X 윈도우 시스템 서버와 그래픽 사용자 인터페이스를 지원하는 이미지까지 다양함

#### oe-init-build-env 스크립트

- `oe-init-build-env` 스크립트는 기본 빌드 환경을 설정함
- 빌드 환경 설정 후 사용할 명령어들이 제대로 작동하려면, 빌드 환경이 현재 쉘에서 실행되어고함 -> `source`를 사용
- `oe-init-build-env` 스크립트를 실행하면 현재의 디렉터리가 build 디렉터리로 바뀌고, build 디렉터리 아래 conf 라는 디렉터리가 생기고, 안에 3개의 파일이 생성됨

```
- poky_src
  - build
    - conf
      - bblayers.conf
      - local.conf
      - templateconf.cfg
```

- bblayers.conf : 생성된 레이어들의 정보를 bitbake에게 알려줌
  - 레이어들의 경로는 BBLAYERS 변수에 할당됨.
  - meta, meta-poky, meta-yocto-bsp 3개의 기본 레이어를 포함
- local.conf : 환경 설정 파일로 bitbake.conf 파일에서 이 파일을 include 하여 사용
  - 타깃 머신을 지정 (타깃 머신 : 나중에도종 산출물인 이미지가 다운로드 되어 동작할 타깃)
  - 크로스 툴체인 지정
  - 전역적으로 필요한 전역 변수에 대한 처리를 이 파일에 넣을 수 있음
- templateconf.cfg : 프로젝트를 생성하는 데 사용되는 템플릿 환경 설정 파일(.conf)을 포함하는 디렉터리를 포함 (기본값 : meta-poky-conf)

#### 오픈 임베디드 코어에서 기본적으로 지원되는 머신

```
- qemuarm
- qemuarm64
- qemumips
- qemumips64
- qemuppc
- qemux86-64
- qemux86
```

> 참고 : meta-yocto-bsp 레이어도 참고할 수 있는 여러 머신들이 더 있으나, 우리는 meta-yocto-bsp를 사용하지 않기 때문에 이 머신들은 언급하지 않음

## 빌드 결과를 QEMU 에뮬레이터로 실행

- `core-image-minimal.bb` 이미지 생성 레시피를 통해 빌드한 결과를 QEMU를 통해 실행해보자
- qemu를 실행하는 명령어는 `runqemu` 임
- `runqemu`는 스크립트 파일이고, `poky/scripts/runqemu`에 위치함

```bash
# runqemu <recipe name>
runqemu core-image-minimal nographic
...
qemux86-64 login: ...
```

- `nographic` 옵션은 비디오 콘솔을 따로 생성하지 않게 함
- 실행하면 login 화면이 나오고, root라고 입력하여 로그인을 해본다
- 종료시에는 `poweroff`를 입력하면 됨

## bitbake 환경 변수 옵션을 통한 변수값 확인

- 오픈임베디드 빌드 시스템에서는 어떤 기능 사용을 위해 `inherit`라는 지시어를 통해 클래스 파일을 상속하고 클래스 파일에서 정의된 변수에 특정한 값을 넣기만 하면 원하는 기능을 쉽게 구현할 수 있음
- 그래서 오픈임베디드 빌드 시스템에서 정의한 변수를 추적하고 확인해야 하는 일이 자주 발생함

```bash
# bitbake의 환경 변수 옵션을 통한 변수값 확인
bitbake core-image-minimal -e > env.txt
```

- `core-image-minimal` 레시피 파일이 사용하는 모든 환경 변수를 env.txt 에 출력함
- `env.txt` 파일을 열어 어떤 변수가 어디에서 선언되었고, 어떤 값이 최종적으로 할당 되었는지 볼 수 있다.

```bash
# 특정 변수의 값만 출력하고 싶을 때
bitbake core-image-minimal -e | grep ^DL_DIR
```

- `DL_DIR`로 시작하는 모든 줄만 필터링하여 출력

```bash
# bitbake-getvar 명령을 사용하여 변수의 값을 출력하는 방법
bitbake-getvar -r core-image-minmal DL_DIR
```

- `bitbake-getvar`를 사용하여 변수의 값을 출력할 수도 있음
- 위 명령을 사용하면 변수 `DL_DIR`이 어떤 변화를 거쳐 최종 값을 할당 받았는지 과정까지 세세하게 나옴

## 리눅스 호스트를 위한 소프트웨어 빌드 과정과 오픈임베디드 빌드 시스템의 빌드 과정 비교

#### 리눅스 호스트를 위한 소프트웨어 빌드 과정

1. fetch : 소스 코드를 다운로드 하고 빌드할 위치에 가져다 놓는다.
2. unpack : 압축된 파일이라면 압축을 해제한다.
3. patch : 버그 수정이나 기능 추가를 위한 패치가 존재한다면 패치를 적용한다.
4. configure : 환경(호스트 아키텍처)에 맞게 빌드 절차를 준비한다.
5. compile : 소스 코드를 컴파일 한다.
6. install : 빌드 산출물을 해당하는 디렉터리에 복사한다.

#### 오픈임베디드 빌드 시스템 빌드 과정

- 오픈임베디드 빌드 시스템도 위와 비슷한 과정을 거치나, 큰 차이가 있음
- 차이점 : 빌드를 진행할 때 타깃 시스템에서 진행하는 것이 아니라 리눅스PC(x86)에서 진행함
- 우리가 만드는 이니지는 타깃 시스템은 다른 아키텍처(보통 arm)에서 동작해야함
- 그래서 호스트에서 빌드를 진행하려면 크로스 툴체인이 필요하고 + 빌드 결과물인 이미지를 타깃 시스템에 설치하고 사용할 때는 패키지 관리 시스템을 사용해야 함
- 실제 타깃 빌드에 사용될 컴파일러는 호스트 PC 환경의 빌드 패키지를 사용해 빌드됨 -> 이게 호스트에 빌드 패키지가 설치되어야 하는 이유임
- ubuntu에서 C, C++ 등을 개발하려고 컴파일 할 때, `stdio.h: No such file or directory` 메시지를 보는 경우
  - 개발에 필요한 stdio.h 등의 기본 라이브러리가 없어 발생하는 문제임
  - 빌드 패키지인 build-essential 패키지를 설치하면 문제가 해결됨
  - `sudo apt install build-essential`

```
  source 저장 공간 (Local storage, upstream source, scm등)
    ↓
 --------------
| source fetch |
|   ↓          |
| unpack       |
|   ↓          |
| patch        |
|   ↓          | ← metadata
| configure    |
|    ↓         |
| compile      |
|   ↓          |
| install      |
 --------------
    ↓
  package
    ↓
  rootfs
```

1. bitbake는 metadata를 분석해 어떤 일을 해야하는지 파악하고 Yocto 프로젝트에서 제공한 커스텀 리눅스를 빌드하는데 필요한 소스들을 외부에서 받아옴
2. 받아온 소스를 컴파일하고 그 결과물을 패키지로 만듦
3. 최종적으로 루트 파일 시스템 이미지가 만들어짐

> 앞으로 위에 내용을 하나씩 살펴보며 Yocto에 대한 이해를 높여갈 예정

## 요약

- Poky는 크게 오픈임베디드 빌드 시스템인 bitbake 빌드 도구 + 오픈임베디드 코어와 함께 추가적인 메타데이터들과 빌드스크립트로 이루어짐
- 아직 다루지는 않았지만, 배포 정책을 포함하고 있는 Poky 레이어와 참조 BSP 레이어도 함께 존재함
- Poky는 커스텀 리눅스 빌드를 할 수 있도록 많은 메타데이터를 가지고 있음
- 이 메타데이터를 이용해 bitbake가 커스텀 리눅스 빌드를 진행하게 됨
- 메타데이터가 모여있는 핵심 디렉터리인 meta는 오픈임베디드 코어라고 불림
- 오픈임베디드 코어는 플랫폼 독립적이고 배포 독립적인 메타데이터를 포함하는 레이어로 gliibc, gcc 컴파일러, 시스템, 일부 타깃을 지원하는 BSP 그리고 툴들과 서비스를 가지고 있음
- 리눅스 빌드 과정과 오픈 임베디드 빌드 시스템 빌드 과정의 가장 큰 차이점은 아래와 같음
  - 리눅스 빌드의 경우, 컴파일과 실행을 동일한 기계에서 수행하는 것이 가능함
  - 오픈임베디드 빌드 시스템의 경우, 컴파일은 호스트(x86)에서 하더라도 실제 실행은 타깃 시스템에서 해야하는 크로스 컴파일 환경을 갖고 있음
  - 따라서 호스트(x86) 타깃 시스템에 맞는 툴체인을 사용해 컴파일, 링크들을 수행해야하는데 이 툴체인을 크로스 툴체인이라고 함
  - 최종적으로 나온 이미지들을 패키지로 만들어 루트 파일 시스템에 설치함
  - 최종 루트 파일 시스템 이미지는 커널, 부트로더 이미지와 함께 타깃 시스템에 프로그래밍돼 타깃을 실행함

#### 루트 파일 시스템이란? (by gemini)

```
🌳 루트 파일 시스템 (Root File System, rootfs)이란?
루트 파일 시스템은 운영 체제(특히 Linux/Unix 계열)에서 계층적 파일 시스템 트리의 최상위에 위치하는 파일 시스템입니다. 이는 **루트 경로(/)**에 마운트되며, 시스템의 부팅 및 정상적인 운영에 필수적인 모든 기본 파일과 디렉터리를 담고 있는 저장소입니다.

🔑 주요 역할 및 특징
루트 파일 시스템은 시스템이 시작되고 사용될 수 있도록 하는 핵심 기반을 제공합니다.
• 최상위 경로(/): 모든 파일과 디렉터리의 시작점입니다. 모든 다른 파일 시스템(예: /usr, /home, /var 등)은 루트 파일 시스템 아래의 특정 디렉터리(마운트 지점)에 연결됩니다.
• 부팅 필수 파일 포함: 운영체제가 부팅되고 초기화되는 데 필요한 커널 모듈, 기본 실행 파일, 라이브러리, 그리고 설정 파일 등이 들어 있습니다.
• /bin: 부팅 시와 부팅 후 일반 사용자에게 필요한 기본 명령어가 포함됩니다.
• /sbin: 시스템 부팅 및 관리와 관련된 시스템 관리자 전용 명령어가 포함됩니다.
• /etc: 호스트 설정 파일(예: /etc/hosts, /etc/passwd)이 포함됩니다.
• /lib: 부팅에 필요한 필수 공유 라이브러리가 포함됩니다.
• /dev: 장치 파일이 포함되어 하드웨어에 접근할 수 있게 합니다.
• 시스템 운영의 기초: 루트 파일 시스템이 손상되면, 시스템이 정상적으로 부팅되지 않거나 작동하지 않을 수 있으므로 매우 중요합니다.
```
